<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="underscore-min.js"></script>
<script type="text/javascript" src="std.js"></script>
<script type="text/javascript" src="pullSim.js"></script>
<h2>Pull Algorithms</h2>
<p>When designing a game that revolves around getting collectibles of some kind through a random pull, it’s hard to actually visualize how that algorithm is going to play out. As it is difficult to fully grasp the consequences of these random distributions it is difficult to design these systems perfectly. Over the course of this article, I’m going to present a bunch of small simulations to help understand various algorithms.</p>
<h3>Table of Contents</h3>
<p><ul>
    <li><a href="#chap1">Basic Player Engagement</a><ul>
        <li><a href="#chap1a">Stimulation</a></li>
        <li><a href="#chap1b">On The Simplifications of the Article</a></li>
        <li><a href="#chap1c">Different Things Are Differently Engaging</a></li>
    </ul></li>
    <li><a href="#chap2">Systems of Engagement</a></li>
    <li><a href="#chap3">Pull Systems</a><ul>
        <li><a href="#chap3a">Simple Simulations</a></li>
        <li><a href="#chap3b">Pokemon Go</a></li>
    </ul></li>
    <li><a href="#chap5">Introducing New Content</a></li>
    <li><a href="#chap6">Various Pull Algorithms</a><ul>
        <li><a href="chap6a">Deterministic</a></li>
        <li><a href="#chap6b">Placing a Ceiling on Bad Pulls</a></li>
        <li><a href="#chap6c">Pokemon Red and Blue</a></li>
    </ul></li>
    <li><a href="#conclusion">Conclusion</a></li>
</ul></p>
<h3><a name="chap1">Basic Player Engagement</a></h3>
<h4><a name="chap1a">Stimulation</a></h4>
<p>This is our first simulation and it’s pretty simple. Just click on the players to engage them. Different players require different amounts of engagement. If a player receives too little stimulation, they will get bored and leave. If they receive too much, they will be overstimulated and will leave.</p>
<table><tr>
    <td><canvas id="sim1" width="480px" height="320px" align="center"></canvas></td>
    <td><button id="sim1Inter1">Interact!</button>
</tr></table>
<h4><a name="chap1b">On The Simplifications of the Article</a></h4>
<p>This is an obvious and gross simplification of player retention. I can see at least the following false assumptions:<ul>
    <li><b>Players retain as long as they are engaged</b> - This just is not something that you can guarantee. Players will leave sometimes even if they are still having fun with your game. They only have so much time in a day.</li>
    <li><b>Players need a baseline of engagement</b> - I personally have stuck with games that I’ve found less than engaging for a variety of reasons. Sometimes, that’s just the right game for the moment.</li>
</ul></p>
<p>I’m going to add another assumption to this list, <b>a game that keeps players engaged is more likely to keep players</b>. I don’t actually have any proof of this, but it seems reasonable enough to make and lets us ignore the falsity of the previous assumptions as irrelevant. Essentially, while an individual person is likely to be a lot less predictable than the person we are simulating, optimizing for this simulated person will also optimize for your player base as a whole.</p>
<p>Remember though that this is a simplification aimed to help you think about a single axis. A new feature could do well in this simulation, but still be bad for your game due to something that this article doesn’t cover, such as negatively impacting the decision making in the game or increasing complexity to the point of impenetrability. Video games are complex and need to be looked at with multiple lenses.</p>
<h4><a name="chap1c">Different Things Are Differently Engaging</a></h4>
<p>Now, let’s try the earlier simulation with a variety of things to engage the player with.</p>
<table><tr>
    <td><canvas id="sim1c" width="480px" height="320px" align="center"></canvas></td>
    <td>
      <button id="sim1cInter1">Interact!</button>
      <br />
      <button id="sim1cInter2">Interact!</button>
</td></tr></table>
<h3><a name="chap2">Systems of Engagement</a></h3>
<p>A common game development pattern is to use a system to drive the player’s engagement instead of hand-crafting it in the manner of the above simulations. It’s often time consuming and expensive to keep clicking on a player. So, with this simulation, we’re going to go over a basic system to do that for us.</p>
<table><tr>
    <td>
      <table>
      <tr><td><canvas id="sim2" width="480px" height="320px" align="center"></canvas></td></tr>
      <tr><td><canvas id="graph2" width="480px" height="320px" align="center"></canvas></td></tr>
      </table>
    </td>
    <td>
      <p>Engagemement per second</p>
      <input id="input2_eps" type="range" min="0" max="30" value="0"><span id="disp2_eps">0</span>
      <p>Zoom</p>
      <input id="input2_zoom" type="range" min="1" max="5" value="1"><span id="disp2_zoom">1</span>
      <p>Boredom Factor</p>
      <input id="input2_bore" type="range" min="0" max="5" value="1"><span id="disp2_bore">1</span>
</td></tr></table>
<h3><a name="chap3">Pull Systems</a></h3>
<h4><a name="chap3a">Simple Simulation</a></h4>
<p>This article is actually only going to focus on one specific kind of engagement system. We’re going to look at a couple of pull algorithms, or algorithms for giving players pieces in a random or semi-random way.</p>
<p>The impetus for this piece came from watching Pokemon Go release the second generation of Pokemon into the wild, so we’re going to use that game as the primary example for the rest of the piece. In particular, we’re going to look at the way players randomly encounter new Pokemon to catch, and consider that a pull system. We’re going to start with the most abstract representation, where we’ll just assume that all of the pieces are of equal value and we’ll assume 100 of them. We're also going to take out over-stimulation for these simulations as it only comes up with collection games where the pieces require effort from the player. We're also going to make people get bored faster so that we can see people start dropping out as they have most of the pieces.</p>
<table><tr>
    <td>
      <table>
        <tr><td><canvas id="sim3" width="480px" height="320px" align="center"></canvas></td></tr>
        <tr><td><canvas id="graph3" width="480px" height="320px" align="center"></canvas></td></tr>
      </table>
    </td>
    <td>
      <p>Pulls per second</p>
      <input id="input3_eps" type="range" min="0" max="30" value="0"><span id="disp3_eps">0</span>
      <p>Zoom</p>
      <input id="input3_zoom" type="range" min="1" max="5" value="1"><span id="disp3_zoom">1</span>
      <p>Boredom Factor</p>
      <input id="input3_bore" type="range" min="0" max="5" value="1"><span id="disp3_bore">1</span>
      <p>Number of Pieces</p>
      <input id="input3_count" type="range" min="100" max="500" value="100" step="10"><span id="disp3_count">100</span>
      <p>Value of New Piece</p>
      <input id="input3_newVal" type="range" min="0" max="5" value="2"><span id="disp3_newVal">2</span>
      <p>Value of Duplicate Piece</p>
      <input id="input3_oldVal" type="range" min="0" max="5" value="0"><span id="disp3_oldVal">0</span>
      <br />
      <br />
      <p>Average Number of Pulls: <span id="data3_1"></span></p>
      <p>Average Number of Unique Pieces: <span id="data3_2"></span></p>
    </td>
</tr></table>
<p>We’re making a few assumptions at this point, and they are at best only partially true. These are:<ul>
    <li><b>Getting things is equivalent to being engaged</b> - This is a hard one to make definitive statements about. I think that getting things is a piece of the puzzle that is engagement, but not the full thing. Its importance changes greatly depending on the kind of game and the consequences of getting a new piece. I personally feel that players need to feel like they are getting value for their time and when a game revolves around collection, this means that they need to collect something meaningful occasionally.</li>
    <li><b>Potential value of a pull is meaningless</b> - ie; players don't care about what they can get, they care about what they did get. This is clearly false. When players have things that they are excited to get, then they are naturally more excited about the chance to get those things. However, that is a layer of complexity too far for these simulations, so the calculation of those effects are left as an exercise for the reader. However, this excitement is a major part of the player experience and you should keep it in mind when designing your own systems.</li>
    <li><b>Pull rate is constant</b> - Again, this is just to keep this article simple. In the real world, the rate can be as complex as you want it to be.</li>
</ul></p>
<h3><a name="chap3b">Pokemon Go</a></h3>
<p>Let’s get a little deeper into what a real pull system looks like. Taking Pokemon Go itself, different Pokemon are differently valuable due to the following axes:<ul>
    <li><b>Intrinsic Value</b> - Pokemon have value to players beyond that of simple gameplay. People who like puppies are probably going to like Growlithes no matter what the stats are.</li>
    <li><b>Not having caught it before</b> - This is a collection game and you want to Catch ‘Em All, so getting a Pokemon that you have not caught before is naturally going to be a major reward moment for most players.</li>
    <li><b>Evolution</b> - This is similar to the previous one, if of lower intensity. Being able to convert a piece into one that you have yet to get is valuable to players.</li>
    <li><b>Combat value</b> - Getting a Pokemon that is stronger than the ones you already have or that is able to power up a major member of your team is valuable to players.</li>
</ul></p>
<p>We're not going to simulate all of that, just something a little closer to it than the simulation above. Note, that at this level of abstraction, this data can represent a lot of games, not just Pokemon Go.</p>
<table><tr>
    <td>
      <table>
        <tr><td><canvas id="sim3b" width="480px" height="320px" align="center"></canvas></td></tr>
        <tr><td><canvas id="graph3b" width="480px" height="320px" align="center"></canvas></td></tr>
      </table>
    </td>
    <td>
      <p>Pulls per second</p>
      <input id="input3b_eps" type="range" min="0" max="30" value="0"><span id="disp3b_eps">0</span>
      <p>Zoom</p>
      <input id="input3b_zoom" type="range" min="1" max="5" value="1"><span id="disp3b_zoom">1</span>
      <p>Boredom Factor</p>
      <input id="input3b_bore" type="range" min="0" max="5" value="1"><span id="disp3b_bore">1</span>
      <br />
      <br />
      <p>Average Number of Pulls: <span id="data3b_1"></span></p>
      <p>Average Number of Unique Pieces: <span id="data3b_2"></span></p>
    </td>
</tr></table>
<h3><a name="chap5">Introducing New Content</a></h3>
<p>Pokemon Go, when introducing the second generation, just added more pieces to their existing pulls. Releasing like that when your players have already performed a large number of pulls results in a graph that looks something like the below one.</p>
<table><tr>
    <td>
      <table>
        <tr><td><canvas id="sim5" width="480px" height="320px" align="center"></canvas></td></tr>
        <tr><td><canvas id="graph5" width="480px" height="320px" align="center"></canvas></td></tr>
      </table>
    </td>
    <td>
      <p>Pulls per second</p>
      <input id="input5_eps" type="range" min="0" max="30" value="0"><span id="disp5_eps">0</span>
      <p>Zoom</p>
      <input id="input5_zoom" type="range" min="1" max="5" value="1"><span id="disp5_zoom">1</span>
      <p>Boredom Factor</p>
      <input id="input5_bore" type="range" min="0" max="5" value="1"><span id="disp5_bore">1</span>
      <p>Number of Old Pieces</p>
      <input id="input5_count" type="range" min="100" max="500" value="100" step="10"><span id="disp5_count">100</span>
      <p>Number of New Pieces</p>
      <input id="input5_newCount" type="range" min="0" max="500" value="100" step="10"><span id="disp5_newCount">100</span>
      <p>Starting Number of Pulls</p>
      <input id="input5_startPulls" type="range" min="0" max="2000" value="0" step="50"><span id="disp5_startPulls">0</span>
      <p>Value of New Piece</p>
      <input id="input5_newVal" type="range" min="0" max="5" value="2"><span id="disp5_newVal">2</span>
      <p>Value of Duplicate Piece</p>
      <input id="input5_oldVal" type="range" min="0" max="5" value="0"><span id="disp5_oldVal">0</span>
      <br />
      <br />
      <p>Average Number of Pulls: <span id="data5_1"></span></p>
      <p>Average Number of Unique Pieces: <span id="data5_2"></span></p>
    </td>
</tr></table>
<p>For comparison, you can set one of the above graphs to the same parameters to see what your engagement curve would look like if you just only let people pull from the new items. Of course, this is not practical as your players want the abilty to catch them all, but it is notable how much worse the graphs for this scenario look.</p>
<h3><a name="chap6">Various Pull Algorithms</a></h3>
<p>We've only worked with simple, highly random pull algorithms thus far. In this section, we'll take a look at some other kinds.</p>
<h4><a name="chap6a">Deterministic</a></h4>
<p>What does this graph look like in the trivial case of just going through every element one by one?</p>
<table><tr>
    <td>
      <table>
        <tr><td><canvas id="sim6a" width="480px" height="320px" align="center"></canvas></td></tr>
        <tr><td><canvas id="graph6a" width="480px" height="320px" align="center"></canvas></td></tr>
      </table>
    </td>
    <td>
      <p>Pulls per second</p>
      <input id="input6a_eps" type="range" min="0" max="30" value="0"><span id="disp6a_eps">0</span>
      <p>Zoom</p>
      <input id="input6a_zoom" type="range" min="1" max="5" value="1"><span id="disp6a_zoom">1</span>
      <p>Boredom Factor</p>
      <input id="input6a_bore" type="range" min="0" max="5" value="1"><span id="disp6a_bore">1</span>
      <p>Number of Pieces</p>
      <input id="input6a_count" type="range" min="100" max="500" value="100" step="10"><span id="disp6a_count">100</span>
      <p>Value of New Piece</p>
      <input id="input6a_newVal" type="range" min="0" max="5" value="2"><span id="disp6a_newVal">2</span>
      <p>Value of Duplicate Piece</p>
      <input id="input6a_oldVal" type="range" min="0" max="5" value="0"><span id="disp6a_oldVal">0</span>
      <br />
      <br />
      <p>Average Number of Pulls: <span id="data6a_1"></span></p>
      <p>Average Number of Unique Pieces: <span id="data6a_2"></span></p>
    </td>
</tr></table>
<p>This simulation is the clearest way to demonstrate the failings of these simulations. It <i>feels</i> very different for players to get random pulls and to get deterministic pulls. One reason for this is that being able to calculate the effort required for something changes the way players value that thing. These simulations have no way to model that though. They can only show you what players get.</p>
<h3><a name="chap6b">Placing a Ceiling on Bad Pulls</a></h3>
<p>A common approach to smooth out the variance of a pull system is to place a ceiling on the number of low-value pulls. That results in graphs that look like this:</p>
<table><tr>
    <td>
      <table>
        <tr><td><canvas id="sim6b" width="480px" height="320px" align="center"></canvas></td></tr>
        <tr><td><canvas id="graph6b" width="480px" height="320px" align="center"></canvas></td></tr>
      </table>
    </td>
    <td>
      <p>Pulls per second</p>
      <input id="input6b_eps" type="range" min="0" max="30" value="0"><span id="disp6b_eps">0</span>
      <p>Zoom</p>
      <input id="input6b_zoom" type="range" min="1" max="5" value="1"><span id="disp6b_zoom">1</span>
      <p>Boredom Factor</p>
      <input id="input6b_bore" type="range" min="0" max="5" value="1"><span id="disp6b_bore">1</span>
      <p>Number of Pieces</p>
      <input id="input6b_count" type="range" min="100" max="500" value="100" step="10"><span id="disp6b_count">100</span>
      <p>Value of New Piece</p>
      <input id="input6b_newVal" type="range" min="0" max="5" value="2"><span id="disp6b_newVal">2</span>
      <p>Value of Duplicate Piece</p>
      <input id="input6b_oldVal" type="range" min="0" max="5" value="0"><span id="disp6b_oldVal">0</span>
      <p>Bad Pull Cap</p>
      <input id="input6b_pullCap" type="range" min="0" max="250" value="0" step="10"><span id="disp6b_pullCap">0</span>
      <br />
      <br />
      <p>Average Number of Pulls: <span id="data6b_1"></span></p>
      <p>Average Number of Unique Pieces: <span id="data6b_2"></span></p>
    </td>
</tr></table>
<p>On a personal note, I dislike it when games do this without communicating the skew to the player because I feel it reinforces the gambler’s fallacy. I also feel that making the cap more explicit is a better experience for the player as the player doesn’t feel like bad pulls help them get to good pulls when it is implicit.</p>
<h3><a name="chap6c">Pokemon Red and Blue</a></h3>
<p>Another option is to divide your pool of pulls across a lot of smaller pools and then let the player move between them. This is essentially what <i>Pokemon Red</i> did and also what a game like <i>Heroes Charge</i> does as well. This changes the flow to be much wavier, and so the graph looks more like this:</p>
<table><tr>
    <td>
      <table>
        <tr><td><canvas id="sim6c" width="480px" height="320px" align="center"></canvas></td></tr>
        <tr><td><canvas id="graph6c" width="480px" height="320px" align="center"></canvas></td></tr>
      </table>
    </td>
    <td>
      <p>Pulls per second</p>
      <input id="input6c_eps" type="range" min="0" max="30" value="0"><span id="disp6c_eps">0</span>
      <p>Zoom</p>
      <input id="input6c_zoom" type="range" min="1" max="5" value="1"><span id="disp6c_zoom">1</span>
      <p>Boredom Factor</p>
      <input id="input6c_bore" type="range" min="0" max="5" value="1"><span id="disp6c_bore">1</span>
      <p>Number of Old Pieces</p>
      <input id="input6c_count" type="range" min="100" max="500" value="100" step="10"><span id="disp6c_count">100</span>
      <p>Number of New Pieces</p>
      <input id="input6c_newCount" type="range" min="0" max="500" value="100" step="10"><span id="disp6c_newCount">100</span>
      <p>Starting Number of Pulls</p>
      <input id="input6c_startPulls" type="range" min="0" max="2000" value="0" step="50"><span id="disp6c_startPulls">0</span>
      <p>Value of New Piece</p>
      <input id="input6c_newVal" type="range" min="0" max="5" value="2"><span id="disp6c_newVal">2</span>
      <p>Value of Duplicate Piece</p>
      <input id="input6c_oldVal" type="range" min="0" max="5" value="0"><span id="disp6c_oldVal">0</span>
      <br />
      <br />
      <p>Average Number of Pulls: <span id="data6c_1"></span></p>
      <p>Average Number of Unique Pieces: <span id="data6c_2"></span></p>
    </td>
</tr></table>
<p>Of course, there are a lot of ways to implement a division like this and the amount of effort required is dependent on the kind of separation that you want to make.</p>
<h3><a name="conclusion">Conclusion</a></h3>
<p>This is, of course, a very incomplete taxonomy. Hopefully though, it lets you think about how players interact with the pull systems that you have made and the potential problems and benefits of these solutions.</p>
<p>You can look through the source code here - </p>
<p>If you have any feedback on this or if you want to see more things like this, you can reach me on Twitter at <a href="">@murthynikhil</a>. If you make any new simulations like this, please do tell me. I’d love to see more explanations like this. Also, if you want to support this work, you can do so here - [patreon]</p>
